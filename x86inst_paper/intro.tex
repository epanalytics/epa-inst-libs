\section{Introduction}

Binary instrumentation toolkits enable insertion of additional code into an
executable in order to observe or modify the behavior of application runs. 
Instrumentation toolkits such as Pin\cite{luk2005pin}, Dynint\cite{buck2000api}, 
Valgrind\cite{nethercote2007valgrind}, DynamoRIO\cite{bruening2004efficient} have been widely used to gather information about the
application runs to be later used in modeling and optimization
of the applications. It has been shown that data gathered 
from such binary instrumentation tools can be effectively used in guiding hardware and
system design, program debugging and correctness, compiler optimizations,
performance modeling/prediction, and security verification \cite{snavely2001modeling}.

There are two main approaches to binary instrumentation: \textit{static} 
and \textit{dynamic} binary instrumentation. Static binary
instrumentation inserts additional code in to an executable and generates a new
executable with the instrumentation whereas the dynamic instrumentation inserts additional code 
at runtime during  execution without any permanent modifications to the executable.
 The static approach has the advantage of usually being able to produce
more efficient  executable compared to the dynamic approach
since static instrumentation introduces only the instrumentation code itself 
 and includes it into the text section of the executable. Unlike static instrumentation, dynamic
instrumentation may insert additional code in to the program heap and use the data section as text space.
However, static binary instrumentation has disadvantages. It is not possible to instrument shared libraries 
unless the shared libraries are instrumented separately and executable is informed to use those libraries. 
Static instrumentation also provides less flexibility to tool developers, since any instrumentation code that is
inserted persists throughout the application run where as dynamic instrumentation 
provides means to delete instrumentation code when it is not needed \cite{tikir2002efficient}.
However, there are cases where efficiency is of enough importance to outweigh
these shortcomings in static instrumentation \cite{carrington2006performance} such that static binary instrumentation is the
desirable paradigm.

In this paper, we introduce a static binary instrumentation toolkit, \textit{PIX}, for Linux on
x86/x86\_64 platforms. The goal of PIX is to provide the ability
to build instrumentation tools that produce efficient instrumented
executable. Similar to previous instrumentation toolkits \cite{buck2000api}, we instrument the executable 
by placing a jump instruction at each instrumentation
point that transfers control to instrumentation code. This instrumentation code saves the
program state, performs tasks that are determined by the instrumentation,
restores the program state, then returns control to the application.
A typical binary instrumentation tool on a platform with fixed-length instructions 
\cite{tikir2006pmac} accomplishes initial control transfer by replacing a
single instruction at the instrumentation point with a jump that transfers
control to the instrumentation code. However when instructions are variable-length, as
is the case for x86/x86\_64, this is not always possible since there may not be enough space for 
inserting the jump instruction correctly. To address this, PIX
relocates and reorganizes the code for each function to ensure that enough
space (in the form of \begin{it}nops\end{it}) is available to hold a full-length branch instruction at each
instrumentation point.

Instrumented code efficiency is accomplished in several ways in PIX. Dynamic binary instrumentation
incurs additional runtime cost because the instrumentation tool performs additional tasks such 
as parsing, disassembly, code generation, and other decisions at runtime. This
 is simply not an issue with static binary instrumentation tools as all
decisions and actions are taken prior to runtime. The only cost born at runtime is the direct
cost of performing instrumentation-related functions. In PIX, we relocate the 
functions in the executable, which affords us the opportunity to reorganize the code so that we
can use large yet efficient instructions to transfer control from the
application to the instrumentation code. We also use the concept of an
instrumentation snippet, as in Dyninst, a lightweight hand-written body of assembly code that can
be inserted into the application rather than relying only on heavyweight
instrumentation functions to accomplish instrumentation tasks.

The PIX toolkit is open source and available to the public for download 
at \url{http://blind-review-forbids-real-urls.com/}. The distribution includes already implemented tools 
including a function execution counter, a basic block
execution counter, and a memory address stream collection tool.

The remainder of the paper is organized as follows. Section
\ref{Section:Overview} describes the design and implementation of PIX.
Section \ref{Section:Efficiency} discusses
several aspects of the toolkit, including the function relocation mechanism and the
instrumentation snippet. Section \ref{Section:Tools} shows the details of
the instrumentation tools included in the package. Section \ref{Section:Results}
presents a comparison of the performance of applications instrumented by out PIX to
the other state of the art instrumentation toolkits including Dyninst, Pin, Valgrind and DynamoRIO. Section
\ref{Section:Future} discusses the future of PIX, and Section \ref{Section:Conclusions} concludes.
