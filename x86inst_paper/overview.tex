\section{Overview}

Instrumentation generally requires the use of code and data that are not part of the original
application's code and data in order to perform some task. In order to insert additional code
and data into an executable, additional space needs to be allocated within the executable in a way that they
will, at load-time, be treated as code and data respectively. Most compilers produce an ELF executable whose
structure is similar to that shown in Figure \ref{Figure:OrigExecutable}. By
convention, most ELF executables use only two loadable segments and indeed some Linux
implementations, such as FreeBSD, only allow two loadable segments. Thus, it is
preferable to incorporate instrumentation text and data into the
existing text and data segments of the application. 

\subsection{Code and Data Discovery}
When compilers explicitly produce a text and data segment, most default to placing the text segment prior and adjacent to the data segment.
However in a typical ELF executable, code and data can reside together in the text section of the executable due to several reasons, including
the storage of branch target locations (e.g. for a jump table that results from a switch statements) or small data structures 
that provide convenient and efficient look-up of data such as identifiers and descriptors. 
For the sake of correctness of the executable after instrumentation, it is extremely important to identify the parts of the text 
section that are code and the parts that are data. Mishandling of existing data in the text section as code 
may result in different instrumented application behavior than the original behavior, especially 
if the instrumentation tool chooses to modify or relocate some part of that data 
to serve the needs of the instrumentation tool. 
Such a change in program behavior may cause application failure due to some unexpected change in control flow 
or some state condition that is checked by the program.
However, the corruption of the data in text section might silently manifest itself by modifying the output of the
program, which is undesirable because can be very difficult to detect. Alternatively, if code is mistakenly treated as data in the text section, instrumentation might
mistakenly not be inserted into instrumentation code or analysis performed that should be reserved for
application data alone. While this is almost certainly preferable to the situation where data is treated as code, it
is ideal to avoid both situations completely for instrumentation and any resulting analysis to be complete and correct.

To determine which parts of the text sections are functions that are eligible to be subject to its code discovery algorithm, 
PIX uses the program's symbol table entries\footnote{The use of the program's symbol table requires that the program be compiled
with debugging information, -g in most cases} to guide it to every function's entry point. Our code discovery algorithm
consists of two phases; control-driven disassembly backed up by linear disassembly. During the control-driven disassembly phase, 
PIX follows all understandable control paths starting at a function's entry point. If a problem is encountered during disassembly such as 
finding an undefined opcode or a branch that jumps into the middle of a previously disassembled instruction, 
PIX falls back to naive disassembly. During the naive disassembly phase, each instruction is disassembled in the order it appears in the
function beginning at the function's entry point. If again a problem such as an undefined opcode or an inconsistent control flow target 
is found, the function is tagged as uninstrumentable.

Problems that can be encountered during both phases of code discovery
are situations where an unknown opcode is encountered, where control jumps to the
middle of an instruction PIX has already disassembled, or if control leaves the boundaries of the function via a traditional branch
instruction. In most
cases control-driven disassembly is sufficient to disassemble the entirety of a function, and in most cases control-driven
disassembly is a straightforward process because control either falls through to the following instruction 
or the location of another possible control target is embedded entirely within the instruction itself. But there are also cases
where an indirect branch is used, the target residing either at a fixed address (possibly with some offset), in a register, 
or at a location given by a register. The latter two cases are difficult to resolve
without runtime information since the computation of the target address can be arbitrarily complex and can span function
boundaries. Nevertheless, PIX performs a peephole examination of the preceeding instructions and can determine 
the target address in most of the cases.

Fortunately, simple calculations are all that most compilers use to determine targets for jump tables, one of the more common
uses of an indirect branch. Often an offset is added to a fixed location to determine where the data comprising the branch target
resides. Therefore, such a fixed address is treated as the first entry in a table whose entries are consiered to be either addresses or offsets.
PIX makes an iterative pass over this table to determine the target for each entry in the jump table, stopping when it finds a value in the
table that yields an address that is outside the scope of the function.

\subsection{Additional Code and Data Insertion}

To accomodate the code and data needed for instrumentation, PIX prepends the instrumentation code to the existing text
segment\footnote{The amount of space allocated prior to the text section is
controlled by the linker variable \_\_executable\_start. There are cases
where the system does not provide enough space prior to the text segment by
default, in which case PIX comes with a set of tools that produces a modified linker
script on the system that provides up to 128MB of space.} and appends the instrumentation data to the
data segment, as shown in Figure \ref{Figure:InstExecutable}). This
scheme has the added benefit of causing no immediate disturbance to the
addresses of the original data and most of the original text of the program.

\begin{figure}[ht]
\centering
\caption[Optional caption for list of figures]{\subref{Figure:OrigExecutable} and \subref{Figure:InstExecutable} show the prepending
of instrumentation text to the existing text, and the prepending of instrumentation data to the existing data respectively.}
\subfigure[Layout of an unmodified ELF file.]{
\includegraphics[scale=0.65]{executablep1.eps}
\label{Figure:OrigExecutable}
}
\subfigure[Layout of an instrumented ELF file.]{
\includegraphics[scale=0.65]{executablep2.eps}
\label{Figure:InstExecutable}
}
\label{Figure:Executable}
\end{figure}

The instrumentation code introduced by PIX serves several distinct functions. The first
is the code that accomplishes the instrumentation tasks as well as any bookkeeping code.
When control is transferred from the application to the
instrumentation code, it is necessary to maintain the machine state of
the application to preserve its original behavior. This machine state
can contain anything modified by the instrumentation code, but in practice is
usually limited to a relatively limited set of registers but in some cases includes
some information about the call stack. The code sequence, called a \textit{trampoline} \cite{buck2000api}, 
saves any machine state that will be destoryed, performs the instrumentation task, restores
the machine state after the instrumentation, executes the
original instructions that were displaced by the initial control transfer,
and finally restores control to the original code. Since a jump instruction is used at the instrumentation point, the
instrumentation code has no information about where control was transferred from
(as might be the case if the more heavyweight call instruction was used). Hence
each instrumentation point uses its own trampoline so that the location of the
instrumentation point can be hard-coded into an unconditional branch instruction
at the end of the trampoline.

Since some instrumentation tools may need additional data to support the inserted instrumentation code,
PIX provides mechanisms to insert and initialize additional data within the executable.
The instrumentation text also includes code to initialize this additional data for use by the
instrumentation tool. Recall from Figure \ref{Figure:Executable} that the instrumentation
data was appended to the end of the application's data segment, after the
application's uninitialized data section (BSS section) in order to preserve the application's 
original addresses. The initialized data and BSS
sections of the data segment are usually implemented in an ELF executable by declaring the size of
the data segment in the executable to be smaller than the size of the data
segment in memory. According to the ELF specification\cite{standard1995executable}, the extra part of any
segment whose memory size is greater than its file size should be filled with
zeroes by the loader. Hence most programs just increase the size of the data
segment in memory by the size of the BSS section in order to get a large
area that is filled with zeroes, which is reserved for uninitialized data. Since the area following the BSS section is well-suited for
storing additional data for the instrumentation tool, either the entire
segment's contents must be included in the executable file or space can be implicitly reserved using the
technique currently employed in most ELF files.
Since the BSS section can be very large and explicit inclusion of its contents
would bloat the executable file uncessesarily, PIX uses the implicit
technique to reserve this section for instrumentation data. Therefore the instrumentation data is
temporarily stored with the instrumentation text in the
executable. This data must then be copied to the correct location in the data segment once execution
of the instrumented executable begins, thus some code to copy accomplish this is included in the
instrumentation text as well.
